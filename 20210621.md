### 146 LRU Cache Medium

#### 2021.6.21

time limit exceeded

    class LRUCache {
        private Map<Integer, Integer> map;
        private Deque<Integer> mostRecentKey;
        private int capacity;
        
        public LRUCache(int capacity) {
            map = new HashMap<>();
            mostRecentKey = new LinkedList<>();
            this.capacity = capacity;
        }
        
        public int get(int key) {
            int value = map.getOrDefault(key, -1);
            if (value != -1) {
                mostRecentKey.remove(key);
                mostRecentKey.addLast(key);
            }
            return value;
        }
        
        public void put(int key, int value) {        
            if (map.containsKey(key)) {
                mostRecentKey.remove(key);
            } else if (map.size() == capacity) {
                int leastRecentKey = mostRecentKey.removeFirst();
                map.remove(leastRecentKey);
            }
            map.put(key, value);
            mostRecentKey.addLast(key);
        }
    }

看了答案后做的

    class LRUCache extends LinkedHashMap<Integer, Integer> {
        private int capacity;
        
        public LRUCache(int capacity) {
            super(capacity, 0.75F, true);
            this.capacity = capacity;
        }
        
        public int get(int key) {
            return super.getOrDefault(key, -1);
        }
        
        public void put(int key, int value) {        
            super.put(key, value);
        }
        
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest) {
            return size() > capacity;
        }
    }
    
看了第二种解答做的

    class LRUCache {
        private class Node {
            int key;
            int value;
            Node prev;
            Node next;
    
            Node(int key, int value) {
                this.key = key;
                this.value = value;
            }
        }
        
        private class DLList {
            private Node head;
            private Node tail;
            
            DLList() {
                head = new Node(-1, -1);
                tail = new Node(-1, -1);
                head.next = tail;
                head.prev = tail;
                tail.next = head;
                tail.prev = head;
            }
            
            void remove(Node node) {
                node.prev.next = node.next;
                node.next.prev = node.prev;
            }
            
            void moveToFront(Node node) {
                remove(node);
                addFirst(node);
            }
            
            void addFirst(Node node) {
                node.prev = head;
                node.next = head.next;
                node.prev.next = node;
                node.next.prev = node;
            }
            
            Node removeLast() {
                Node last = tail.prev;
                
                tail.prev = tail.prev.prev;
                tail.prev.next = tail;
                
                return last;
            }
        }
        
        private Map<Integer, Node> map;
        private DLList list;
        private int capacity;
        
        public LRUCache(int capacity) {
            map = new HashMap<>();
            list = new DLList();
            this.capacity = capacity;
        }
        
        public int get(int key) {
            Node node = map.getOrDefault(key, null);
            if (node == null) {
                return -1;
            }
            list.moveToFront(node);
            return node.value;
        }
        
        public void put(int key, int value) {
            Node node = map.getOrDefault(key, null);
            if (node != null) {
                node.value = value;
                list.moveToFront(node);
            } else {
                Node newNode = new Node(key, value);
                map.put(key, newNode);
                list.addFirst(newNode);
                
                if (map.size() > capacity) {
                    Node last = list.removeLast();
                    
                    map.remove(last.key);
                }
            }
        }
    }

### 207 Course Schedule I Medium

#### 2021.6.22

看了第一个答案做的。time limit exceeded


    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            Map<Integer, List<Integer>> courses = new HashMap<>();
            
            for (int i = 0; i < prerequisites.length; i++) {
                List<Integer> nextCourses = courses.getOrDefault(prerequisites[i][1], new ArrayList<Integer>());
                nextCourses.add(prerequisites[i][0]);
                courses.put(prerequisites[i][1], nextCourses);
            }
            
            boolean[] path = new boolean[numCourses];
            for (int i = 0; i < numCourses; i++) {
                if (isCyclic(i, path, courses)) {
                    return false;
                }
            }
            
            return true;
        }
        
        private boolean isCyclic(int start, boolean[] path, Map<Integer, List<Integer>> courses) {
            if (path[start]) {
                return true;
            }
            
            if (!courses.containsKey(start)) {
                return false;
            }
            
            path[start] = true;
            for (int nextCourse : courses.get(start)) {
                if (isCyclic(nextCourse, path, courses)) {
                    return true;
                }
            }
            
            path[start] = false;
            return false;
        }
    }

看了答案的第二个后又做了一遍。其实和第一遍的思路一样，只不过加了一个memoization的数组

    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            Map<Integer, List<Integer>> courseDict = new HashMap<>();
            
            for (int i = 0; i < prerequisites.length; i++) {
                List<Integer> nextCourses = courseDict.getOrDefault(prerequisites[i][1], new ArrayList<>());
                nextCourses.add(prerequisites[i][0]);
                courseDict.put(prerequisites[i][1], nextCourses);
            }
            
            boolean[] path = new boolean[numCourses];
            boolean[] checked = new boolean[numCourses];
            
            for (int course = 0; course < numCourses; course++) {
                if (isCyclic(course, path, checked, courseDict)) {
                    return false;
                }
            }
            
            return true;
        }
        
        private boolean isCyclic(int start, boolean[] path, boolean[] checked, Map<Integer, List<Integer>> courseDict) {
            if (checked[start]) {
                return false;
            }
            
            if (path[start]) {
                return true;
            }
            
            if (!courseDict.containsKey(start)) {
                return false;
            }
            
            path[start] = true;
            
            for (int next : courseDict.get(start)) {
                if (isCyclic(next, path, checked, courseDict)) {
                    return true;
                }
            }
            
            path[start] = false;
            checked[start] = true;
            
            return false;
        }
    }

### 36. Valid Sudoku Medium

#### 2021.6.22

自己做的

    class Solution {
        public boolean isValidSudoku(char[][] board) {
            for (int i = 0; i < board.length; i++) {
                Set<Character> set = new HashSet<>();
                for (int j = 0; j < board[i].length; j++) {
                    if (board[i][j] != '.' && set.contains(board[i][j])) {
                        return false;
                    }
                    set.add(board[i][j]);
                }
                set.clear();
            }
            
            for (int col = 0; col < 9; col++) {
                Set<Character> set = new HashSet<>();
                for (int row = 0; row < 9; row++) {
                    char c = board[row][col];
                    if (c != '.' && set.contains(c)) {
                        return false;
                    }
                    set.add(c);
                }
                set.clear();
            }
            
            for (int row = 0; row < 3; row++) {
                for (int col = 0; col < 3; col++) {
                    Set<Character> set = new HashSet<>();
                    for (int i = row * 3; i < (row + 1) * 3; i++) {
                        for (int j = col * 3; j < (col + 1) * 3; j++) {
                            char c = board[i][j];
                            if (c != '.' && set.contains(c)) {
                                return false;
                            }
                            set.add(c);
                        }
                    }
                    set.clear();
                }
            }
            
            return true;               
        }
    }

看了答案后做的

    class Solution {
        public boolean isValidSudoku(char[][] board) {
            Set<String> set = new HashSet<>();
            
            for (int row = 0; row < 9; row++) {
                for (int col = 0; col < 9; col++) {
                    char c = board[row][col];
                    if (c != '.') {
                        if (!set.add(c + " in row " + row) 
                            || !set.add(c + " in col " + col)
                            || !set.add(c + " at block " + row / 3 + '-' + col / 3)) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
    }


### 733. Flood Fill Easy

#### 2021.6.22

自己做的

    class Solution {
        public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
            int oldColor = image[sr][sc];
            
            if (newColor != oldColor) {
                floodFill(image, sr, sc, newColor, oldColor);
            }
            
            return image;
        }
        
        private void floodFill(int[][] image, int sr, int sc, int newColor, int oldColor) {
            if (image[sr][sc] != oldColor) {
                return;
            }
            
            image[sr][sc] = newColor;
            
            if (sc - 1 >= 0) {
                floodFill(image, sr, sc - 1, newColor, oldColor);
            }
            
            if (sc + 1 < image[0].length) {
                floodFill(image, sr, sc + 1, newColor, oldColor);
            }
            
            if (sr - 1 >= 0) {
                floodFill(image, sr - 1, sc, newColor, oldColor);
            }
            
            if (sr + 1 < image.length) {
                floodFill(image, sr + 1, sc, newColor, oldColor);
            }
        }
    }
    
### 673. Number of Longest Increasing Subsequence Medium

#### 2021.6.22

好难。。答案都看了半天

    class Solution {
        public int findNumberOfLIS(int[] nums) {
            int[] count = new int[nums.length];
            int[] len = new int[nums.length];
            
            int maxLen = 0;
            int maxCount = 0;
            for (int i = 0; i < nums.length; i++) {
                count[i] = 1;
                len[i] = 1;
                for (int j = 0; j < i; j++) {
                    if (nums[i] > nums[j]) {
                        if (len[i] == len[j] + 1) {
                            count[i] = count[i] + count[j];
                        } else if (len[i] < len[j] + 1) {
                            count[i] = count[j];
                            len[i] = len[j] + 1;
                        }
                    }
                }
                
                if (len[i] == maxLen) {
                    maxCount = maxCount + count[i];
                } else if (len[i] > maxLen) {
                    maxCount = count[i];
                    maxLen = len[i];
                }
            }
            
            return maxCount;
        }    
    }

### lc 863. All Nodes Distance K in Binary Tree Medium

#### 2021.6.23

看了答案后做的

    class Solution {
        public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
            Map<TreeNode, TreeNode> parentMap = new HashMap<>();
            getParent(null, root, parentMap);
            
            Queue<TreeNode> queue = new LinkedList<>();
            Set<Integer> seen = new HashSet<>();
            
            int level = 0;
            int count = 1;
            List<Integer> output = new ArrayList<>();
            
            queue.add(target);
            seen.add(target.val);
            while (!queue.isEmpty()) {
                // Number of nodes at the current level
                int numNodes = count;
                count = 0;
                for (int i = 0; i < numNodes; i++){
                    TreeNode node = queue.poll();
                    
                    if (level == k) {
                        output.add(node.val);
                    } else {
                        if (node.left != null && !seen.contains(node.left.val)) {
                            queue.add(node.left);
                            seen.add(node.left.val);
                            count++;
                        }
                        
                        if (node.right != null && !seen.contains(node.right.val)) {
                            queue.add(node.right);
                            seen.add(node.right.val);
                            count++;
                        }
                        
                        TreeNode parent = parentMap.get(node);
                        if (parent != null && !seen.contains(parent.val)) {
                            queue.add(parent);
                            seen.add(parent.val);
                            count++;
                        }
                    }
                }
                
                level = level + 1;
            }
            
            return output;
        }
        
        private void getParent(TreeNode parent, TreeNode curr, Map<TreeNode, TreeNode> parentMap) {
            if (curr != null) {
                parentMap.put(curr, parent);
                getParent(curr, curr.left, parentMap);
                getParent(curr, curr.right, parentMap);
            }
        }
    }
    
 - 不过其实可以更简单，不用queue, 就是不停地找next level的节点，执行k次就可以了

### 55 Jump Game Medium

#### 2021.6.24

自己做的

    class Solution {
        public boolean canJump(int[] nums) {
            boolean[] canJump = new boolean[nums.length];
            canJump[nums.length - 1] = true;
            
            for (int i = nums.length - 2; i >= 0; i--) {
                for (int j = 1; j <= nums[i]; j++) {
                    if (i + j < nums.length && canJump[i + j]) {
                        canJump[i] = true;
                        break;
                    }
                }
            }
            
            return canJump[0];
        }
    }

看了答案后做的

    class Solution {
        public boolean canJump(int[] nums) {
            int lastGoodPosition = nums.length - 1;
            
            for (int i = nums.length - 2; i >= 0; i--) {
                if (i + nums[i] >= lastGoodPosition) {
                    lastGoodPosition = i;
                }
            }
            
            return lastGoodPosition == 0;
        }
    }

### 62 Unique Paths Medium

#### 2021.6.24

自己做的

    class Solution {
        public int uniquePaths(int m, int n) {
            int[][] numPaths = new int[m][n];
            
            for (int row = m - 1; row >= 0; row--) {
                for (int col = n - 1; col >= 0; col--) {
                    if (row == m - 1 || col == n - 1) {
                        numPaths[row][col] = 1;
                    } else {
                        numPaths[row][col] = numPaths[row + 1][col] + numPaths[row][col + 1];
                    }
                }
            }
            
            return numPaths[0][0];
        }
    }

space complexity 可以优化成 `O(n)`

    class Solution {
        public int uniquePaths(int m, int n) {
            int[] memo = new int[n];
            Arrays.fill(memo, 1);
            
            
            for (int i = 0; i < m - 1; i++) {
                for (int j = memo.length - 2; j >= 0; j--) {
                    memo[j] = memo[j] + memo[j + 1];
                }
            }
            
            return memo[0];
        }
    }

space complexity可以进一步优化成： `O(min(m, n))`

    class Solution {
        public int uniquePaths(int m, int n) {
            if (n > m) {
                int tmp = n;
                n = m;
                m = tmp;
            }
            
            int[] memo = new int[n];
            Arrays.fill(memo, 1);   
            
            for (int i = 0; i < m - 1; i++) {
                for (int j = memo.length - 2; j >= 0; j--) {
                    memo[j] = memo[j] + memo[j + 1];
                }
            }
            
            return memo[0];
        }
    }

### 75 Sort Colors Medium

#### 2021.6.24

自己做的, 思路来源于283

    class Solution {
        public void sortColors(int[] nums) {
            int p2 = 0;
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] != 2) {
                    swap(nums, i, p2);
                    p2++;
                }
            }
            
            int p1 = 0;
            for (int i = 0; i < p2; i++) {
                if (nums[i] != 1) {
                    swap(nums, i, p1);
                    p1++;
                }
            }
        }
        
        private void swap(int[] nums, int i, int j) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    }

看了答案后重做的

    class Solution {
        public void sortColors(int[] nums) {
            int p0 = 0;
            int p2 = nums.length - 1;
            int curr = 0;
            
            while (curr <= p2) {
                if (nums[curr] == 0) {
                    swap(nums, p0, curr);
                    p0++;
                    curr++;
                } else if (nums[curr] == 2) {
                    swap(nums, p2, curr);
                    p2--;
                } else {
                    curr++;
                }
            }
        }
        
        private void swap(int[] nums, int i, int j) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    }

### 64. Minimum Path Sum

#### 2021.6.25

自己做的

    class Solution {
        public int minPathSum(int[][] grid) {
            int m = grid.length;
            int n = grid[0].length;
            
            int[][] sum = new int[m][n];
            for (int row = m - 1; row >= 0; row--) {
                for (int col = n - 1; col >= 0; col--) {
                    if (row == m - 1 && col == n - 1) {
                        sum[row][col] = grid[row][col];
                    } else if (row == m - 1) {
                        sum[row][col] = grid[row][col] + sum[row][col + 1];
                    } else if (col == n - 1) {
                        sum[row][col] = grid[row][col] + sum[row + 1][col];
                    } else {
                        sum[row][col] = grid[row][col] + Math.min(sum[row][col + 1], sum[row + 1][col]);
                    }
                }
            }
            
            return sum[0][0];
        }
    }

减少了complexity做了一遍

    class Solution {
        public int minPathSum(int[][] grid) {
            int m = grid.length;
            int n = grid[0].length;
            
            int[] sum = new int[n];
            for (int row = m - 1; row >= 0; row--) {
                for (int col = n - 1; col >= 0; col--) {
                    if (row == m - 1) {
                        if (col == n - 1) {
                            sum[col] = grid[row][col];
                        } else {
                            sum[col] = grid[row][col] + sum[col + 1];
                        }
                    } else {
                        if (col == n - 1) {
                            sum[col] = sum[col] + grid[row][col];
                        } else {
                            sum[col] = grid[row][col] + Math.min(sum[col], sum[col + 1]);
                        }
                    }
                }
            }
            
            return sum[0];
        }
    }

 - 当然了，还可以修改输入array。这是我万万没想到的

### 78 Subsets Medium

#### 2021.6.25

自己做的 backtracking


    class Solution {
        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> output = new ArrayList<>();
            
            List<Integer> set = new ArrayList<>();
            
            backtrack(0, set, output, nums);
            
            return output;
        }
        
        private void backtrack(int start, List<Integer> set, List<List<Integer>> output, int[] nums) {
            if (start == nums.length) {
                output.add(new ArrayList(set));
                return;
            }
            
            backtrack(start + 1, set, output, nums);
    
            set.add(nums[start]);
            
            backtrack(start + 1, set, output, nums);
            
            set.remove(set.size() - 1);
        }
    }

看了答案用cascading的方法做了一遍

    class Solution {
        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> output = new ArrayList<>();
            
            output.add(new ArrayList<>());
            
            for (int num : nums) {
                int n = output.size();
                for (int i = 0; i < n; i++) {
                    List<Integer> list = output.get(i);
                    List<Integer> newList = new ArrayList<>(list);
                    newList.add(num);
                    output.add(newList);
                }
            }
            
            return output;
        }
    }
    
用bitmask的方法又做了一遍

    class Solution {
        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> output = new ArrayList<>();
            
            int n = nums.length;
            
            for (int i = (int) Math.pow(2, n); i < (int) Math.pow(2, n + 1); i++) {
                String bitmask = Integer.toBinaryString(i).substring(1);
                
                List<Integer> list = new ArrayList<>();
                for (int j = 0; j < bitmask.length(); j++) {
                    if (bitmask.charAt(j) == '1') {
                        list.add(nums[j]);
                    }
                }
                
                output.add(list);
            }
            
            return output;
        }
    }


### 128. Longest Consecutive Sequence

#### 2021.6.25

    class Solution {
        public int longestConsecutive(int[] nums) {
            Set<Integer> set = new HashSet<>();
            for (int num : nums) {
                set.add(num);
            }
            
            int maxLength = 0;
            for (int num : set) {
                if (!set.contains(num - 1)) {
                    int currLength = 1;
                    
                    while (set.contains(num + 1)) {
                        currLength++;
                        num++;
                    }
                    
                    maxLength = Math.max(currLength, maxLength);
                }
            }
            
            return maxLength;
        }
    }

### 79 Word Search Medium

#### 2021.6.25

自己做的

    class Solution {
        public boolean exist(char[][] board, String word) {
            int m = board.length;
            int n = board[0].length;
            boolean[][] visited = new boolean[m][n];
            
            for (int row = 0; row < m; row++) {
                for (int col = 0; col < n; col++) {
                    if (search(board, word, visited, row, col)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        private boolean search(char[][] board, String str, boolean[][] visited, int row, int col) {
            if (str.length() == 0) {
                return true;
            }
            
            if (row >= 0 && row <= board.length - 1 
                && col >= 0 && col <= board[0].length - 1 
                && !visited[row][col] 
                && str.charAt(0) == board[row][col]) {
                
                visited[row][col] = true;
                String subStr = str.substring(1);
                if (search(board, subStr, visited, row - 1, col)
                   || search(board, subStr, visited, row + 1, col)
                   || search(board, subStr, visited, row, col - 1)
                   || search(board, subStr, visited, row, col + 1)) {
                    return true;
                }
                visited[row][col] = false;
            }
            
            return false;
        }
    }

 - 当然，与其创建一个新的boolean array, 也可以修改输入array