### 146 LRU Cache Medium

#### 2021.6.21

time limit exceeded

    class LRUCache {
        private Map<Integer, Integer> map;
        private Deque<Integer> mostRecentKey;
        private int capacity;
        
        public LRUCache(int capacity) {
            map = new HashMap<>();
            mostRecentKey = new LinkedList<>();
            this.capacity = capacity;
        }
        
        public int get(int key) {
            int value = map.getOrDefault(key, -1);
            if (value != -1) {
                mostRecentKey.remove(key);
                mostRecentKey.addLast(key);
            }
            return value;
        }
        
        public void put(int key, int value) {        
            if (map.containsKey(key)) {
                mostRecentKey.remove(key);
            } else if (map.size() == capacity) {
                int leastRecentKey = mostRecentKey.removeFirst();
                map.remove(leastRecentKey);
            }
            map.put(key, value);
            mostRecentKey.addLast(key);
        }
    }

看了答案后做的

    class LRUCache extends LinkedHashMap<Integer, Integer> {
        private int capacity;
        
        public LRUCache(int capacity) {
            super(capacity, 0.75F, true);
            this.capacity = capacity;
        }
        
        public int get(int key) {
            return super.getOrDefault(key, -1);
        }
        
        public void put(int key, int value) {        
            super.put(key, value);
        }
        
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest) {
            return size() > capacity;
        }
    }
    
看了第二种解答做的

    class LRUCache {
        private class Node {
            int key;
            int value;
            Node prev;
            Node next;
    
            Node(int key, int value) {
                this.key = key;
                this.value = value;
            }
        }
        
        private class DLList {
            private Node head;
            private Node tail;
            
            DLList() {
                head = new Node(-1, -1);
                tail = new Node(-1, -1);
                head.next = tail;
                head.prev = tail;
                tail.next = head;
                tail.prev = head;
            }
            
            void remove(Node node) {
                node.prev.next = node.next;
                node.next.prev = node.prev;
            }
            
            void moveToFront(Node node) {
                remove(node);
                addFirst(node);
            }
            
            void addFirst(Node node) {
                node.prev = head;
                node.next = head.next;
                node.prev.next = node;
                node.next.prev = node;
            }
            
            Node removeLast() {
                Node last = tail.prev;
                
                tail.prev = tail.prev.prev;
                tail.prev.next = tail;
                
                return last;
            }
        }
        
        private Map<Integer, Node> map;
        private DLList list;
        private int capacity;
        
        public LRUCache(int capacity) {
            map = new HashMap<>();
            list = new DLList();
            this.capacity = capacity;
        }
        
        public int get(int key) {
            Node node = map.getOrDefault(key, null);
            if (node == null) {
                return -1;
            }
            list.moveToFront(node);
            return node.value;
        }
        
        public void put(int key, int value) {
            Node node = map.getOrDefault(key, null);
            if (node != null) {
                node.value = value;
                list.moveToFront(node);
            } else {
                Node newNode = new Node(key, value);
                map.put(key, newNode);
                list.addFirst(newNode);
                
                if (map.size() > capacity) {
                    Node last = list.removeLast();
                    
                    map.remove(last.key);
                }
            }
        }
    }

### 207 Course Schedule I Medium

#### 2021.6.22

看了第一个答案做的。time limit exceeded


    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            Map<Integer, List<Integer>> courses = new HashMap<>();
            
            for (int i = 0; i < prerequisites.length; i++) {
                List<Integer> nextCourses = courses.getOrDefault(prerequisites[i][1], new ArrayList<Integer>());
                nextCourses.add(prerequisites[i][0]);
                courses.put(prerequisites[i][1], nextCourses);
            }
            
            boolean[] path = new boolean[numCourses];
            for (int i = 0; i < numCourses; i++) {
                if (isCyclic(i, path, courses)) {
                    return false;
                }
            }
            
            return true;
        }
        
        private boolean isCyclic(int start, boolean[] path, Map<Integer, List<Integer>> courses) {
            if (path[start]) {
                return true;
            }
            
            if (!courses.containsKey(start)) {
                return false;
            }
            
            path[start] = true;
            for (int nextCourse : courses.get(start)) {
                if (isCyclic(nextCourse, path, courses)) {
                    return true;
                }
            }
            
            path[start] = false;
            return false;
        }
    }

看了答案的第二个后又做了一遍。其实和第一遍的思路一样，只不过加了一个memoization的数组

    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            Map<Integer, List<Integer>> courseDict = new HashMap<>();
            
            for (int i = 0; i < prerequisites.length; i++) {
                List<Integer> nextCourses = courseDict.getOrDefault(prerequisites[i][1], new ArrayList<>());
                nextCourses.add(prerequisites[i][0]);
                courseDict.put(prerequisites[i][1], nextCourses);
            }
            
            boolean[] path = new boolean[numCourses];
            boolean[] checked = new boolean[numCourses];
            
            for (int course = 0; course < numCourses; course++) {
                if (isCyclic(course, path, checked, courseDict)) {
                    return false;
                }
            }
            
            return true;
        }
        
        private boolean isCyclic(int start, boolean[] path, boolean[] checked, Map<Integer, List<Integer>> courseDict) {
            if (checked[start]) {
                return false;
            }
            
            if (path[start]) {
                return true;
            }
            
            if (!courseDict.containsKey(start)) {
                return false;
            }
            
            path[start] = true;
            
            for (int next : courseDict.get(start)) {
                if (isCyclic(next, path, checked, courseDict)) {
                    return true;
                }
            }
            
            path[start] = false;
            checked[start] = true;
            
            return false;
        }
    }

### 36. Valid Sudoku Medium

#### 2021.6.22

自己做的

    class Solution {
        public boolean isValidSudoku(char[][] board) {
            for (int i = 0; i < board.length; i++) {
                Set<Character> set = new HashSet<>();
                for (int j = 0; j < board[i].length; j++) {
                    if (board[i][j] != '.' && set.contains(board[i][j])) {
                        return false;
                    }
                    set.add(board[i][j]);
                }
                set.clear();
            }
            
            for (int col = 0; col < 9; col++) {
                Set<Character> set = new HashSet<>();
                for (int row = 0; row < 9; row++) {
                    char c = board[row][col];
                    if (c != '.' && set.contains(c)) {
                        return false;
                    }
                    set.add(c);
                }
                set.clear();
            }
            
            for (int row = 0; row < 3; row++) {
                for (int col = 0; col < 3; col++) {
                    Set<Character> set = new HashSet<>();
                    for (int i = row * 3; i < (row + 1) * 3; i++) {
                        for (int j = col * 3; j < (col + 1) * 3; j++) {
                            char c = board[i][j];
                            if (c != '.' && set.contains(c)) {
                                return false;
                            }
                            set.add(c);
                        }
                    }
                    set.clear();
                }
            }
            
            return true;               
        }
    }

看了答案后做的

    class Solution {
        public boolean isValidSudoku(char[][] board) {
            Set<String> set = new HashSet<>();
            
            for (int row = 0; row < 9; row++) {
                for (int col = 0; col < 9; col++) {
                    char c = board[row][col];
                    if (c != '.') {
                        if (!set.add(c + " in row " + row) 
                            || !set.add(c + " in col " + col)
                            || !set.add(c + " at block " + row / 3 + '-' + col / 3)) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
    }


### 733. Flood Fill Easy

#### 2021.6.22

自己做的

    class Solution {
        public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
            int oldColor = image[sr][sc];
            
            if (newColor != oldColor) {
                floodFill(image, sr, sc, newColor, oldColor);
            }
            
            return image;
        }
        
        private void floodFill(int[][] image, int sr, int sc, int newColor, int oldColor) {
            if (image[sr][sc] != oldColor) {
                return;
            }
            
            image[sr][sc] = newColor;
            
            if (sc - 1 >= 0) {
                floodFill(image, sr, sc - 1, newColor, oldColor);
            }
            
            if (sc + 1 < image[0].length) {
                floodFill(image, sr, sc + 1, newColor, oldColor);
            }
            
            if (sr - 1 >= 0) {
                floodFill(image, sr - 1, sc, newColor, oldColor);
            }
            
            if (sr + 1 < image.length) {
                floodFill(image, sr + 1, sc, newColor, oldColor);
            }
        }
    }
    
### 673. Number of Longest Increasing Subsequence Medium

#### 2021.6.22

好难。。答案都看了半天

    class Solution {
        public int findNumberOfLIS(int[] nums) {
            int[] count = new int[nums.length];
            int[] len = new int[nums.length];
            
            int maxLen = 0;
            int maxCount = 0;
            for (int i = 0; i < nums.length; i++) {
                count[i] = 1;
                len[i] = 1;
                for (int j = 0; j < i; j++) {
                    if (nums[i] > nums[j]) {
                        if (len[i] == len[j] + 1) {
                            count[i] = count[i] + count[j];
                        } else if (len[i] < len[j] + 1) {
                            count[i] = count[j];
                            len[i] = len[j] + 1;
                        }
                    }
                }
                
                if (len[i] == maxLen) {
                    maxCount = maxCount + count[i];
                } else if (len[i] > maxLen) {
                    maxCount = count[i];
                    maxLen = len[i];
                }
            }
            
            return maxCount;
        }    
    }